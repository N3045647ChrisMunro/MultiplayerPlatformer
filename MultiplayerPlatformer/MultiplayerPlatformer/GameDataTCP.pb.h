// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameDataTCP.proto

#ifndef PROTOBUF_GameDataTCP_2eproto__INCLUDED
#define PROTOBUF_GameDataTCP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace GameDataTCP {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_GameDataTCP_2eproto();
void protobuf_AssignDesc_GameDataTCP_2eproto();
void protobuf_ShutdownFile_GameDataTCP_2eproto();

class ChatMessage;
class DataMessage;
class Login;
class NewPlayerReg;
class Register;

// ===================================================================

class Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataTCP.Register) */ {
 public:
  Register();
  virtual ~Register();

  Register(const Register& from);

  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();

  void Swap(Register* other);

  // implements Message ----------------------------------------------

  inline Register* New() const { return New(NULL); }

  Register* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:GameDataTCP.Register)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataTCP_2eproto();
  friend void protobuf_AssignDesc_GameDataTCP_2eproto();
  friend void protobuf_ShutdownFile_GameDataTCP_2eproto();

  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataTCP.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  inline Login* New() const { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:GameDataTCP.Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataTCP_2eproto();
  friend void protobuf_AssignDesc_GameDataTCP_2eproto();
  friend void protobuf_ShutdownFile_GameDataTCP_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class ChatMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataTCP.ChatMessage) */ {
 public:
  ChatMessage();
  virtual ~ChatMessage();

  ChatMessage(const ChatMessage& from);

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatMessage& default_instance();

  void Swap(ChatMessage* other);

  // implements Message ----------------------------------------------

  inline ChatMessage* New() const { return New(NULL); }

  ChatMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatMessage& from);
  void MergeFrom(const ChatMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChatMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string recipient = 1;
  void clear_recipient();
  static const int kRecipientFieldNumber = 1;
  const ::std::string& recipient() const;
  void set_recipient(const ::std::string& value);
  void set_recipient(const char* value);
  void set_recipient(const char* value, size_t size);
  ::std::string* mutable_recipient();
  ::std::string* release_recipient();
  void set_allocated_recipient(::std::string* recipient);

  // optional string chatMsg = 2;
  void clear_chatmsg();
  static const int kChatMsgFieldNumber = 2;
  const ::std::string& chatmsg() const;
  void set_chatmsg(const ::std::string& value);
  void set_chatmsg(const char* value);
  void set_chatmsg(const char* value, size_t size);
  ::std::string* mutable_chatmsg();
  ::std::string* release_chatmsg();
  void set_allocated_chatmsg(::std::string* chatmsg);

  // @@protoc_insertion_point(class_scope:GameDataTCP.ChatMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr recipient_;
  ::google::protobuf::internal::ArenaStringPtr chatmsg_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataTCP_2eproto();
  friend void protobuf_AssignDesc_GameDataTCP_2eproto();
  friend void protobuf_ShutdownFile_GameDataTCP_2eproto();

  void InitAsDefaultInstance();
  static ChatMessage* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerReg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataTCP.NewPlayerReg) */ {
 public:
  NewPlayerReg();
  virtual ~NewPlayerReg();

  NewPlayerReg(const NewPlayerReg& from);

  inline NewPlayerReg& operator=(const NewPlayerReg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerReg& default_instance();

  void Swap(NewPlayerReg* other);

  // implements Message ----------------------------------------------

  inline NewPlayerReg* New() const { return New(NULL); }

  NewPlayerReg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerReg& from);
  void MergeFrom(const NewPlayerReg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewPlayerReg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:GameDataTCP.NewPlayerReg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataTCP_2eproto();
  friend void protobuf_AssignDesc_GameDataTCP_2eproto();
  friend void protobuf_ShutdownFile_GameDataTCP_2eproto();

  void InitAsDefaultInstance();
  static NewPlayerReg* default_instance_;
};
// -------------------------------------------------------------------

class DataMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataTCP.DataMessage) */ {
 public:
  DataMessage();
  virtual ~DataMessage();

  DataMessage(const DataMessage& from);

  inline DataMessage& operator=(const DataMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMessage& default_instance();

  void Swap(DataMessage* other);

  // implements Message ----------------------------------------------

  inline DataMessage* New() const { return New(NULL); }

  DataMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMessage& from);
  void MergeFrom(const DataMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameDataTCP.Register register = 1;
  bool has_register_() const;
  void clear_register_();
  static const int kRegisterFieldNumber = 1;
  const ::GameDataTCP::Register& register_() const;
  ::GameDataTCP::Register* mutable_register_();
  ::GameDataTCP::Register* release_register_();
  void set_allocated_register_(::GameDataTCP::Register* register_);

  // optional .GameDataTCP.Login login = 2;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 2;
  const ::GameDataTCP::Login& login() const;
  ::GameDataTCP::Login* mutable_login();
  ::GameDataTCP::Login* release_login();
  void set_allocated_login(::GameDataTCP::Login* login);

  // optional .GameDataTCP.ChatMessage chatMessage = 3;
  bool has_chatmessage() const;
  void clear_chatmessage();
  static const int kChatMessageFieldNumber = 3;
  const ::GameDataTCP::ChatMessage& chatmessage() const;
  ::GameDataTCP::ChatMessage* mutable_chatmessage();
  ::GameDataTCP::ChatMessage* release_chatmessage();
  void set_allocated_chatmessage(::GameDataTCP::ChatMessage* chatmessage);

  // repeated .GameDataTCP.NewPlayerReg newPlayerReg = 4;
  int newplayerreg_size() const;
  void clear_newplayerreg();
  static const int kNewPlayerRegFieldNumber = 4;
  const ::GameDataTCP::NewPlayerReg& newplayerreg(int index) const;
  ::GameDataTCP::NewPlayerReg* mutable_newplayerreg(int index);
  ::GameDataTCP::NewPlayerReg* add_newplayerreg();
  ::google::protobuf::RepeatedPtrField< ::GameDataTCP::NewPlayerReg >*
      mutable_newplayerreg();
  const ::google::protobuf::RepeatedPtrField< ::GameDataTCP::NewPlayerReg >&
      newplayerreg() const;

  // @@protoc_insertion_point(class_scope:GameDataTCP.DataMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameDataTCP::Register* register__;
  ::GameDataTCP::Login* login_;
  ::GameDataTCP::ChatMessage* chatmessage_;
  ::google::protobuf::RepeatedPtrField< ::GameDataTCP::NewPlayerReg > newplayerreg_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataTCP_2eproto();
  friend void protobuf_AssignDesc_GameDataTCP_2eproto();
  friend void protobuf_ShutdownFile_GameDataTCP_2eproto();

  void InitAsDefaultInstance();
  static DataMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Register

// optional string username = 1;
inline void Register::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::username() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.Register.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.Register.username)
}
inline void Register::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.Register.username)
}
inline void Register::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.Register.username)
}
inline ::std::string* Register::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.Register.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_username() {
  // @@protoc_insertion_point(field_release:GameDataTCP.Register.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.Register.username)
}

// optional string password = 2;
inline void Register::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Register::password() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.Register.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.Register.password)
}
inline void Register::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.Register.password)
}
inline void Register::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.Register.password)
}
inline ::std::string* Register::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.Register.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Register::release_password() {
  // @@protoc_insertion_point(field_release:GameDataTCP.Register.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Register::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.Register.password)
}

// -------------------------------------------------------------------

// Login

// optional string username = 1;
inline void Login::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::username() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.Login.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.Login.username)
}
inline void Login::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.Login.username)
}
inline void Login::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.Login.username)
}
inline ::std::string* Login::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.Login.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_username() {
  // @@protoc_insertion_point(field_release:GameDataTCP.Login.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.Login.username)
}

// optional string password = 2;
inline void Login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.Login.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.Login.password)
}
inline void Login::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.Login.password)
}
inline void Login::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.Login.password)
}
inline ::std::string* Login::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.Login.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:GameDataTCP.Login.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.Login.password)
}

// -------------------------------------------------------------------

// ChatMessage

// optional string recipient = 1;
inline void ChatMessage::clear_recipient() {
  recipient_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatMessage::recipient() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.ChatMessage.recipient)
  return recipient_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_recipient(const ::std::string& value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.ChatMessage.recipient)
}
inline void ChatMessage::set_recipient(const char* value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.ChatMessage.recipient)
}
inline void ChatMessage::set_recipient(const char* value, size_t size) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.ChatMessage.recipient)
}
inline ::std::string* ChatMessage::mutable_recipient() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.ChatMessage.recipient)
  return recipient_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_recipient() {
  // @@protoc_insertion_point(field_release:GameDataTCP.ChatMessage.recipient)
  
  return recipient_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_recipient(::std::string* recipient) {
  if (recipient != NULL) {
    
  } else {
    
  }
  recipient_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipient);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.ChatMessage.recipient)
}

// optional string chatMsg = 2;
inline void ChatMessage::clear_chatmsg() {
  chatmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ChatMessage::chatmsg() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.ChatMessage.chatMsg)
  return chatmsg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_chatmsg(const ::std::string& value) {
  
  chatmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.ChatMessage.chatMsg)
}
inline void ChatMessage::set_chatmsg(const char* value) {
  
  chatmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.ChatMessage.chatMsg)
}
inline void ChatMessage::set_chatmsg(const char* value, size_t size) {
  
  chatmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.ChatMessage.chatMsg)
}
inline ::std::string* ChatMessage::mutable_chatmsg() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.ChatMessage.chatMsg)
  return chatmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChatMessage::release_chatmsg() {
  // @@protoc_insertion_point(field_release:GameDataTCP.ChatMessage.chatMsg)
  
  return chatmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChatMessage::set_allocated_chatmsg(::std::string* chatmsg) {
  if (chatmsg != NULL) {
    
  } else {
    
  }
  chatmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chatmsg);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.ChatMessage.chatMsg)
}

// -------------------------------------------------------------------

// NewPlayerReg

// optional string username = 1;
inline void NewPlayerReg::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPlayerReg::username() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.NewPlayerReg.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerReg::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.NewPlayerReg.username)
}
inline void NewPlayerReg::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.NewPlayerReg.username)
}
inline void NewPlayerReg::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.NewPlayerReg.username)
}
inline ::std::string* NewPlayerReg::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.NewPlayerReg.username)
	return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPlayerReg::release_username() {
  // @@protoc_insertion_point(field_release:GameDataTCP.NewPlayerReg.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerReg::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.NewPlayerReg.username)
}

// optional string status = 2;
inline void NewPlayerReg::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewPlayerReg::status() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.NewPlayerReg.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerReg::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataTCP.NewPlayerReg.status)
}
inline void NewPlayerReg::set_status(const char* value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataTCP.NewPlayerReg.status)
}
inline void NewPlayerReg::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataTCP.NewPlayerReg.status)
}
inline ::std::string* NewPlayerReg::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:GameDataTCP.NewPlayerReg.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewPlayerReg::release_status() {
  // @@protoc_insertion_point(field_release:GameDataTCP.NewPlayerReg.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewPlayerReg::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.NewPlayerReg.status)
}

// -------------------------------------------------------------------

// DataMessage

// optional .GameDataTCP.Register register = 1;
inline bool DataMessage::has_register_() const {
  return !_is_default_instance_ && register__ != NULL;
}
inline void DataMessage::clear_register_() {
  if (GetArenaNoVirtual() == NULL && register__ != NULL) delete register__;
  register__ = NULL;
}
inline const ::GameDataTCP::Register& DataMessage::register_() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.DataMessage.register)
  return register__ != NULL ? *register__ : *default_instance_->register__;
}
inline ::GameDataTCP::Register* DataMessage::mutable_register_() {
  
  if (register__ == NULL) {
    register__ = new ::GameDataTCP::Register;
  }
  // @@protoc_insertion_point(field_mutable:GameDataTCP.DataMessage.register)
  return register__;
}
inline ::GameDataTCP::Register* DataMessage::release_register_() {
  // @@protoc_insertion_point(field_release:GameDataTCP.DataMessage.register)
  
  ::GameDataTCP::Register* temp = register__;
  register__ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_register_(::GameDataTCP::Register* register_) {
  delete register__;
  register__ = register_;
  if (register_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.DataMessage.register)
}

// optional .GameDataTCP.Login login = 2;
inline bool DataMessage::has_login() const {
  return !_is_default_instance_ && login_ != NULL;
}
inline void DataMessage::clear_login() {
  if (GetArenaNoVirtual() == NULL && login_ != NULL) delete login_;
  login_ = NULL;
}
inline const ::GameDataTCP::Login& DataMessage::login() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.DataMessage.login)
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::GameDataTCP::Login* DataMessage::mutable_login() {
  
  if (login_ == NULL) {
    login_ = new ::GameDataTCP::Login;
  }
  // @@protoc_insertion_point(field_mutable:GameDataTCP.DataMessage.login)
  return login_;
}
inline ::GameDataTCP::Login* DataMessage::release_login() {
  // @@protoc_insertion_point(field_release:GameDataTCP.DataMessage.login)
  
  ::GameDataTCP::Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_login(::GameDataTCP::Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.DataMessage.login)
}

// optional .GameDataTCP.ChatMessage chatMessage = 3;
inline bool DataMessage::has_chatmessage() const {
  return !_is_default_instance_ && chatmessage_ != NULL;
}
inline void DataMessage::clear_chatmessage() {
  if (GetArenaNoVirtual() == NULL && chatmessage_ != NULL) delete chatmessage_;
  chatmessage_ = NULL;
}
inline const ::GameDataTCP::ChatMessage& DataMessage::chatmessage() const {
  // @@protoc_insertion_point(field_get:GameDataTCP.DataMessage.chatMessage)
  return chatmessage_ != NULL ? *chatmessage_ : *default_instance_->chatmessage_;
}
inline ::GameDataTCP::ChatMessage* DataMessage::mutable_chatmessage() {
  
  if (chatmessage_ == NULL) {
    chatmessage_ = new ::GameDataTCP::ChatMessage;
  }
  // @@protoc_insertion_point(field_mutable:GameDataTCP.DataMessage.chatMessage)
  return chatmessage_;
}
inline ::GameDataTCP::ChatMessage* DataMessage::release_chatmessage() {
  // @@protoc_insertion_point(field_release:GameDataTCP.DataMessage.chatMessage)
  
  ::GameDataTCP::ChatMessage* temp = chatmessage_;
  chatmessage_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_chatmessage(::GameDataTCP::ChatMessage* chatmessage) {
  delete chatmessage_;
  chatmessage_ = chatmessage;
  if (chatmessage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataTCP.DataMessage.chatMessage)
}

// repeated .GameDataTCP.NewPlayerReg newPlayerReg = 4;
inline int DataMessage::newplayerreg_size() const {
  return newplayerreg_.size();
}
inline void DataMessage::clear_newplayerreg() {
  newplayerreg_.Clear();
}
inline const ::GameDataTCP::NewPlayerReg& DataMessage::newplayerreg(int index) const {
  // @@protoc_insertion_point(field_get:GameDataTCP.DataMessage.newPlayerReg)
  return newplayerreg_.Get(index);
}
inline ::GameDataTCP::NewPlayerReg* DataMessage::mutable_newplayerreg(int index) {
  // @@protoc_insertion_point(field_mutable:GameDataTCP.DataMessage.newPlayerReg)
  return newplayerreg_.Mutable(index);
}
inline ::GameDataTCP::NewPlayerReg* DataMessage::add_newplayerreg() {
  // @@protoc_insertion_point(field_add:GameDataTCP.DataMessage.newPlayerReg)
  return newplayerreg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GameDataTCP::NewPlayerReg >*
DataMessage::mutable_newplayerreg() {
  // @@protoc_insertion_point(field_mutable_list:GameDataTCP.DataMessage.newPlayerReg)
  return &newplayerreg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GameDataTCP::NewPlayerReg >&
DataMessage::newplayerreg() const {
  // @@protoc_insertion_point(field_list:GameDataTCP.DataMessage.newPlayerReg)
  return newplayerreg_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameDataTCP

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameDataTCP_2eproto__INCLUDED
