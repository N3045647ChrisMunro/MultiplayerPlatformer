// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameDataUDP.proto

#ifndef PROTOBUF_GameDataUDP_2eproto__INCLUDED
#define PROTOBUF_GameDataUDP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace GameDataUDP {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_GameDataUDP_2eproto();
void protobuf_AssignDesc_GameDataUDP_2eproto();
void protobuf_ShutdownFile_GameDataUDP_2eproto();

class BulletPositionUpdate;
class CollisionUpdate;
class DataMessage;
class KeyPress;
class PlayerPositionUpdate;
class PlayerVelcityUpdate;

// ===================================================================

class KeyPress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.KeyPress) */ {
 public:
  KeyPress();
  virtual ~KeyPress();

  KeyPress(const KeyPress& from);

  inline KeyPress& operator=(const KeyPress& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyPress& default_instance();

  void Swap(KeyPress* other);

  // implements Message ----------------------------------------------

  inline KeyPress* New() const { return New(NULL); }

  KeyPress* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyPress& from);
  void MergeFrom(const KeyPress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyPress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:GameDataUDP.KeyPress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static KeyPress* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPositionUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.PlayerPositionUpdate) */ {
 public:
  PlayerPositionUpdate();
  virtual ~PlayerPositionUpdate();

  PlayerPositionUpdate(const PlayerPositionUpdate& from);

  inline PlayerPositionUpdate& operator=(const PlayerPositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPositionUpdate& default_instance();

  void Swap(PlayerPositionUpdate* other);

  // implements Message ----------------------------------------------

  inline PlayerPositionUpdate* New() const { return New(NULL); }

  PlayerPositionUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPositionUpdate& from);
  void MergeFrom(const PlayerPositionUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerPositionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional float xPos = 2;
  void clear_xpos();
  static const int kXPosFieldNumber = 2;
  float xpos() const;
  void set_xpos(float value);

  // optional float yPos = 3;
  void clear_ypos();
  static const int kYPosFieldNumber = 3;
  float ypos() const;
  void set_ypos(float value);

  // @@protoc_insertion_point(class_scope:GameDataUDP.PlayerPositionUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  float xpos_;
  float ypos_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static PlayerPositionUpdate* default_instance_;
};
// -------------------------------------------------------------------

class PlayerVelcityUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.PlayerVelcityUpdate) */ {
 public:
  PlayerVelcityUpdate();
  virtual ~PlayerVelcityUpdate();

  PlayerVelcityUpdate(const PlayerVelcityUpdate& from);

  inline PlayerVelcityUpdate& operator=(const PlayerVelcityUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerVelcityUpdate& default_instance();

  void Swap(PlayerVelcityUpdate* other);

  // implements Message ----------------------------------------------

  inline PlayerVelcityUpdate* New() const { return New(NULL); }

  PlayerVelcityUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerVelcityUpdate& from);
  void MergeFrom(const PlayerVelcityUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerVelcityUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional float xPos = 2;
  void clear_xpos();
  static const int kXPosFieldNumber = 2;
  float xpos() const;
  void set_xpos(float value);

  // optional float yPos = 3;
  void clear_ypos();
  static const int kYPosFieldNumber = 3;
  float ypos() const;
  void set_ypos(float value);

  // @@protoc_insertion_point(class_scope:GameDataUDP.PlayerVelcityUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  float xpos_;
  float ypos_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static PlayerVelcityUpdate* default_instance_;
};
// -------------------------------------------------------------------

class BulletPositionUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.BulletPositionUpdate) */ {
 public:
  BulletPositionUpdate();
  virtual ~BulletPositionUpdate();

  BulletPositionUpdate(const BulletPositionUpdate& from);

  inline BulletPositionUpdate& operator=(const BulletPositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BulletPositionUpdate& default_instance();

  void Swap(BulletPositionUpdate* other);

  // implements Message ----------------------------------------------

  inline BulletPositionUpdate* New() const { return New(NULL); }

  BulletPositionUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BulletPositionUpdate& from);
  void MergeFrom(const BulletPositionUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BulletPositionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string owner = 1;
  void clear_owner();
  static const int kOwnerFieldNumber = 1;
  const ::std::string& owner() const;
  void set_owner(const ::std::string& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  ::std::string* mutable_owner();
  ::std::string* release_owner();
  void set_allocated_owner(::std::string* owner);

  // optional float xPos = 2;
  void clear_xpos();
  static const int kXPosFieldNumber = 2;
  float xpos() const;
  void set_xpos(float value);

  // optional float yPos = 3;
  void clear_ypos();
  static const int kYPosFieldNumber = 3;
  float ypos() const;
  void set_ypos(float value);

  // @@protoc_insertion_point(class_scope:GameDataUDP.BulletPositionUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr owner_;
  float xpos_;
  float ypos_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static BulletPositionUpdate* default_instance_;
};
// -------------------------------------------------------------------

class CollisionUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.CollisionUpdate) */ {
 public:
  CollisionUpdate();
  virtual ~CollisionUpdate();

  CollisionUpdate(const CollisionUpdate& from);

  inline CollisionUpdate& operator=(const CollisionUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionUpdate& default_instance();

  void Swap(CollisionUpdate* other);

  // implements Message ----------------------------------------------

  inline CollisionUpdate* New() const { return New(NULL); }

  CollisionUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollisionUpdate& from);
  void MergeFrom(const CollisionUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CollisionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerHit = 1;
  void clear_playerhit();
  static const int kPlayerHitFieldNumber = 1;
  const ::std::string& playerhit() const;
  void set_playerhit(const ::std::string& value);
  void set_playerhit(const char* value);
  void set_playerhit(const char* value, size_t size);
  ::std::string* mutable_playerhit();
  ::std::string* release_playerhit();
  void set_allocated_playerhit(::std::string* playerhit);

  // optional string object = 2;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // @@protoc_insertion_point(class_scope:GameDataUDP.CollisionUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr playerhit_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static CollisionUpdate* default_instance_;
};
// -------------------------------------------------------------------

class DataMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameDataUDP.DataMessage) */ {
 public:
  DataMessage();
  virtual ~DataMessage();

  DataMessage(const DataMessage& from);

  inline DataMessage& operator=(const DataMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMessage& default_instance();

  void Swap(DataMessage* other);

  // implements Message ----------------------------------------------

  inline DataMessage* New() const { return New(NULL); }

  DataMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMessage& from);
  void MergeFrom(const DataMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GameDataUDP.KeyPress keyPress = 1;
  bool has_keypress() const;
  void clear_keypress();
  static const int kKeyPressFieldNumber = 1;
  const ::GameDataUDP::KeyPress& keypress() const;
  ::GameDataUDP::KeyPress* mutable_keypress();
  ::GameDataUDP::KeyPress* release_keypress();
  void set_allocated_keypress(::GameDataUDP::KeyPress* keypress);

  // optional .GameDataUDP.PlayerPositionUpdate playerPosUpdate = 2;
  bool has_playerposupdate() const;
  void clear_playerposupdate();
  static const int kPlayerPosUpdateFieldNumber = 2;
  const ::GameDataUDP::PlayerPositionUpdate& playerposupdate() const;
  ::GameDataUDP::PlayerPositionUpdate* mutable_playerposupdate();
  ::GameDataUDP::PlayerPositionUpdate* release_playerposupdate();
  void set_allocated_playerposupdate(::GameDataUDP::PlayerPositionUpdate* playerposupdate);

  // optional .GameDataUDP.PlayerVelcityUpdate playerVelocityUpdate = 3;
  bool has_playervelocityupdate() const;
  void clear_playervelocityupdate();
  static const int kPlayerVelocityUpdateFieldNumber = 3;
  const ::GameDataUDP::PlayerVelcityUpdate& playervelocityupdate() const;
  ::GameDataUDP::PlayerVelcityUpdate* mutable_playervelocityupdate();
  ::GameDataUDP::PlayerVelcityUpdate* release_playervelocityupdate();
  void set_allocated_playervelocityupdate(::GameDataUDP::PlayerVelcityUpdate* playervelocityupdate);

  // optional .GameDataUDP.BulletPositionUpdate bulletPosUpdate = 4;
  bool has_bulletposupdate() const;
  void clear_bulletposupdate();
  static const int kBulletPosUpdateFieldNumber = 4;
  const ::GameDataUDP::BulletPositionUpdate& bulletposupdate() const;
  ::GameDataUDP::BulletPositionUpdate* mutable_bulletposupdate();
  ::GameDataUDP::BulletPositionUpdate* release_bulletposupdate();
  void set_allocated_bulletposupdate(::GameDataUDP::BulletPositionUpdate* bulletposupdate);

  // optional .GameDataUDP.CollisionUpdate collisionUpdate = 5;
  bool has_collisionupdate() const;
  void clear_collisionupdate();
  static const int kCollisionUpdateFieldNumber = 5;
  const ::GameDataUDP::CollisionUpdate& collisionupdate() const;
  ::GameDataUDP::CollisionUpdate* mutable_collisionupdate();
  ::GameDataUDP::CollisionUpdate* release_collisionupdate();
  void set_allocated_collisionupdate(::GameDataUDP::CollisionUpdate* collisionupdate);

  // @@protoc_insertion_point(class_scope:GameDataUDP.DataMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::GameDataUDP::KeyPress* keypress_;
  ::GameDataUDP::PlayerPositionUpdate* playerposupdate_;
  ::GameDataUDP::PlayerVelcityUpdate* playervelocityupdate_;
  ::GameDataUDP::BulletPositionUpdate* bulletposupdate_;
  ::GameDataUDP::CollisionUpdate* collisionupdate_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_GameDataUDP_2eproto();
  friend void protobuf_AssignDesc_GameDataUDP_2eproto();
  friend void protobuf_ShutdownFile_GameDataUDP_2eproto();

  void InitAsDefaultInstance();
  static DataMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KeyPress

// optional string username = 1;
inline void KeyPress::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyPress::username() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.KeyPress.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyPress::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.KeyPress.username)
}
inline void KeyPress::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.KeyPress.username)
}
inline void KeyPress::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.KeyPress.username)
}
inline ::std::string* KeyPress::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.KeyPress.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyPress::release_username() {
  // @@protoc_insertion_point(field_release:GameDataUDP.KeyPress.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyPress::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.KeyPress.username)
}

// optional string key = 2;
inline void KeyPress::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyPress::key() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.KeyPress.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyPress::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.KeyPress.key)
}
inline void KeyPress::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.KeyPress.key)
}
inline void KeyPress::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.KeyPress.key)
}
inline ::std::string* KeyPress::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.KeyPress.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyPress::release_key() {
  // @@protoc_insertion_point(field_release:GameDataUDP.KeyPress.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyPress::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.KeyPress.key)
}

// -------------------------------------------------------------------

// PlayerPositionUpdate

// optional string username = 1;
inline void PlayerPositionUpdate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerPositionUpdate::username() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerPositionUpdate.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPositionUpdate::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerPositionUpdate.username)
}
inline void PlayerPositionUpdate::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.PlayerPositionUpdate.username)
}
inline void PlayerPositionUpdate::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.PlayerPositionUpdate.username)
}
inline ::std::string* PlayerPositionUpdate::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.PlayerPositionUpdate.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerPositionUpdate::release_username() {
  // @@protoc_insertion_point(field_release:GameDataUDP.PlayerPositionUpdate.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerPositionUpdate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.PlayerPositionUpdate.username)
}

// optional float xPos = 2;
inline void PlayerPositionUpdate::clear_xpos() {
  xpos_ = 0;
}
inline float PlayerPositionUpdate::xpos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerPositionUpdate.xPos)
  return xpos_;
}
inline void PlayerPositionUpdate::set_xpos(float value) {
  
  xpos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerPositionUpdate.xPos)
}

// optional float yPos = 3;
inline void PlayerPositionUpdate::clear_ypos() {
  ypos_ = 0;
}
inline float PlayerPositionUpdate::ypos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerPositionUpdate.yPos)
  return ypos_;
}
inline void PlayerPositionUpdate::set_ypos(float value) {
  
  ypos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerPositionUpdate.yPos)
}

// -------------------------------------------------------------------

// PlayerVelcityUpdate

// optional string username = 1;
inline void PlayerVelcityUpdate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerVelcityUpdate::username() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerVelcityUpdate.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerVelcityUpdate::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerVelcityUpdate.username)
}
inline void PlayerVelcityUpdate::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.PlayerVelcityUpdate.username)
}
inline void PlayerVelcityUpdate::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.PlayerVelcityUpdate.username)
}
inline ::std::string* PlayerVelcityUpdate::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.PlayerVelcityUpdate.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerVelcityUpdate::release_username() {
  // @@protoc_insertion_point(field_release:GameDataUDP.PlayerVelcityUpdate.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerVelcityUpdate::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.PlayerVelcityUpdate.username)
}

// optional float xPos = 2;
inline void PlayerVelcityUpdate::clear_xpos() {
  xpos_ = 0;
}
inline float PlayerVelcityUpdate::xpos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerVelcityUpdate.xPos)
  return xpos_;
}
inline void PlayerVelcityUpdate::set_xpos(float value) {
  
  xpos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerVelcityUpdate.xPos)
}

// optional float yPos = 3;
inline void PlayerVelcityUpdate::clear_ypos() {
  ypos_ = 0;
}
inline float PlayerVelcityUpdate::ypos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.PlayerVelcityUpdate.yPos)
  return ypos_;
}
inline void PlayerVelcityUpdate::set_ypos(float value) {
  
  ypos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.PlayerVelcityUpdate.yPos)
}

// -------------------------------------------------------------------

// BulletPositionUpdate

// optional string owner = 1;
inline void BulletPositionUpdate::clear_owner() {
  owner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BulletPositionUpdate::owner() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.BulletPositionUpdate.owner)
  return owner_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BulletPositionUpdate::set_owner(const ::std::string& value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.BulletPositionUpdate.owner)
}
inline void BulletPositionUpdate::set_owner(const char* value) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.BulletPositionUpdate.owner)
}
inline void BulletPositionUpdate::set_owner(const char* value, size_t size) {
  
  owner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.BulletPositionUpdate.owner)
}
inline ::std::string* BulletPositionUpdate::mutable_owner() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.BulletPositionUpdate.owner)
  return owner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BulletPositionUpdate::release_owner() {
  // @@protoc_insertion_point(field_release:GameDataUDP.BulletPositionUpdate.owner)
  
  return owner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BulletPositionUpdate::set_allocated_owner(::std::string* owner) {
  if (owner != NULL) {
    
  } else {
    
  }
  owner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.BulletPositionUpdate.owner)
}

// optional float xPos = 2;
inline void BulletPositionUpdate::clear_xpos() {
  xpos_ = 0;
}
inline float BulletPositionUpdate::xpos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.BulletPositionUpdate.xPos)
  return xpos_;
}
inline void BulletPositionUpdate::set_xpos(float value) {
  
  xpos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.BulletPositionUpdate.xPos)
}

// optional float yPos = 3;
inline void BulletPositionUpdate::clear_ypos() {
  ypos_ = 0;
}
inline float BulletPositionUpdate::ypos() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.BulletPositionUpdate.yPos)
  return ypos_;
}
inline void BulletPositionUpdate::set_ypos(float value) {
  
  ypos_ = value;
  // @@protoc_insertion_point(field_set:GameDataUDP.BulletPositionUpdate.yPos)
}

// -------------------------------------------------------------------

// CollisionUpdate

// optional string playerHit = 1;
inline void CollisionUpdate::clear_playerhit() {
  playerhit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CollisionUpdate::playerhit() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.CollisionUpdate.playerHit)
  return playerhit_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CollisionUpdate::set_playerhit(const ::std::string& value) {
  
  playerhit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.CollisionUpdate.playerHit)
}
inline void CollisionUpdate::set_playerhit(const char* value) {
  
  playerhit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.CollisionUpdate.playerHit)
}
inline void CollisionUpdate::set_playerhit(const char* value, size_t size) {
  
  playerhit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.CollisionUpdate.playerHit)
}
inline ::std::string* CollisionUpdate::mutable_playerhit() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.CollisionUpdate.playerHit)
  return playerhit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CollisionUpdate::release_playerhit() {
  // @@protoc_insertion_point(field_release:GameDataUDP.CollisionUpdate.playerHit)
  
  return playerhit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CollisionUpdate::set_allocated_playerhit(::std::string* playerhit) {
  if (playerhit != NULL) {
    
  } else {
    
  }
  playerhit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), playerhit);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.CollisionUpdate.playerHit)
}

// optional string object = 2;
inline void CollisionUpdate::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CollisionUpdate::object() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.CollisionUpdate.object)
  return object_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CollisionUpdate::set_object(const ::std::string& value) {
  
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameDataUDP.CollisionUpdate.object)
}
inline void CollisionUpdate::set_object(const char* value) {
  
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameDataUDP.CollisionUpdate.object)
}
inline void CollisionUpdate::set_object(const char* value, size_t size) {
  
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameDataUDP.CollisionUpdate.object)
}
inline ::std::string* CollisionUpdate::mutable_object() {
  
  // @@protoc_insertion_point(field_mutable:GameDataUDP.CollisionUpdate.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CollisionUpdate::release_object() {
  // @@protoc_insertion_point(field_release:GameDataUDP.CollisionUpdate.object)
  
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CollisionUpdate::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    
  } else {
    
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.CollisionUpdate.object)
}

// -------------------------------------------------------------------

// DataMessage

// optional .GameDataUDP.KeyPress keyPress = 1;
inline bool DataMessage::has_keypress() const {
  return !_is_default_instance_ && keypress_ != NULL;
}
inline void DataMessage::clear_keypress() {
  if (GetArenaNoVirtual() == NULL && keypress_ != NULL) delete keypress_;
  keypress_ = NULL;
}
inline const ::GameDataUDP::KeyPress& DataMessage::keypress() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.DataMessage.keyPress)
  return keypress_ != NULL ? *keypress_ : *default_instance_->keypress_;
}
inline ::GameDataUDP::KeyPress* DataMessage::mutable_keypress() {
  
  if (keypress_ == NULL) {
    keypress_ = new ::GameDataUDP::KeyPress;
  }
  // @@protoc_insertion_point(field_mutable:GameDataUDP.DataMessage.keyPress)
  return keypress_;
}
inline ::GameDataUDP::KeyPress* DataMessage::release_keypress() {
  // @@protoc_insertion_point(field_release:GameDataUDP.DataMessage.keyPress)
  
  ::GameDataUDP::KeyPress* temp = keypress_;
  keypress_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_keypress(::GameDataUDP::KeyPress* keypress) {
  delete keypress_;
  keypress_ = keypress;
  if (keypress) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.DataMessage.keyPress)
}

// optional .GameDataUDP.PlayerPositionUpdate playerPosUpdate = 2;
inline bool DataMessage::has_playerposupdate() const {
  return !_is_default_instance_ && playerposupdate_ != NULL;
}
inline void DataMessage::clear_playerposupdate() {
  if (GetArenaNoVirtual() == NULL && playerposupdate_ != NULL) delete playerposupdate_;
  playerposupdate_ = NULL;
}
inline const ::GameDataUDP::PlayerPositionUpdate& DataMessage::playerposupdate() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.DataMessage.playerPosUpdate)
  return playerposupdate_ != NULL ? *playerposupdate_ : *default_instance_->playerposupdate_;
}
inline ::GameDataUDP::PlayerPositionUpdate* DataMessage::mutable_playerposupdate() {
  
  if (playerposupdate_ == NULL) {
    playerposupdate_ = new ::GameDataUDP::PlayerPositionUpdate;
  }
  // @@protoc_insertion_point(field_mutable:GameDataUDP.DataMessage.playerPosUpdate)
  return playerposupdate_;
}
inline ::GameDataUDP::PlayerPositionUpdate* DataMessage::release_playerposupdate() {
  // @@protoc_insertion_point(field_release:GameDataUDP.DataMessage.playerPosUpdate)
  
  ::GameDataUDP::PlayerPositionUpdate* temp = playerposupdate_;
  playerposupdate_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_playerposupdate(::GameDataUDP::PlayerPositionUpdate* playerposupdate) {
  delete playerposupdate_;
  playerposupdate_ = playerposupdate;
  if (playerposupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.DataMessage.playerPosUpdate)
}

// optional .GameDataUDP.PlayerVelcityUpdate playerVelocityUpdate = 3;
inline bool DataMessage::has_playervelocityupdate() const {
  return !_is_default_instance_ && playervelocityupdate_ != NULL;
}
inline void DataMessage::clear_playervelocityupdate() {
  if (GetArenaNoVirtual() == NULL && playervelocityupdate_ != NULL) delete playervelocityupdate_;
  playervelocityupdate_ = NULL;
}
inline const ::GameDataUDP::PlayerVelcityUpdate& DataMessage::playervelocityupdate() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.DataMessage.playerVelocityUpdate)
  return playervelocityupdate_ != NULL ? *playervelocityupdate_ : *default_instance_->playervelocityupdate_;
}
inline ::GameDataUDP::PlayerVelcityUpdate* DataMessage::mutable_playervelocityupdate() {
  
  if (playervelocityupdate_ == NULL) {
    playervelocityupdate_ = new ::GameDataUDP::PlayerVelcityUpdate;
  }
  // @@protoc_insertion_point(field_mutable:GameDataUDP.DataMessage.playerVelocityUpdate)
  return playervelocityupdate_;
}
inline ::GameDataUDP::PlayerVelcityUpdate* DataMessage::release_playervelocityupdate() {
  // @@protoc_insertion_point(field_release:GameDataUDP.DataMessage.playerVelocityUpdate)
  
  ::GameDataUDP::PlayerVelcityUpdate* temp = playervelocityupdate_;
  playervelocityupdate_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_playervelocityupdate(::GameDataUDP::PlayerVelcityUpdate* playervelocityupdate) {
  delete playervelocityupdate_;
  playervelocityupdate_ = playervelocityupdate;
  if (playervelocityupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.DataMessage.playerVelocityUpdate)
}

// optional .GameDataUDP.BulletPositionUpdate bulletPosUpdate = 4;
inline bool DataMessage::has_bulletposupdate() const {
  return !_is_default_instance_ && bulletposupdate_ != NULL;
}
inline void DataMessage::clear_bulletposupdate() {
  if (GetArenaNoVirtual() == NULL && bulletposupdate_ != NULL) delete bulletposupdate_;
  bulletposupdate_ = NULL;
}
inline const ::GameDataUDP::BulletPositionUpdate& DataMessage::bulletposupdate() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.DataMessage.bulletPosUpdate)
  return bulletposupdate_ != NULL ? *bulletposupdate_ : *default_instance_->bulletposupdate_;
}
inline ::GameDataUDP::BulletPositionUpdate* DataMessage::mutable_bulletposupdate() {
  
  if (bulletposupdate_ == NULL) {
    bulletposupdate_ = new ::GameDataUDP::BulletPositionUpdate;
  }
  // @@protoc_insertion_point(field_mutable:GameDataUDP.DataMessage.bulletPosUpdate)
  return bulletposupdate_;
}
inline ::GameDataUDP::BulletPositionUpdate* DataMessage::release_bulletposupdate() {
  // @@protoc_insertion_point(field_release:GameDataUDP.DataMessage.bulletPosUpdate)
  
  ::GameDataUDP::BulletPositionUpdate* temp = bulletposupdate_;
  bulletposupdate_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_bulletposupdate(::GameDataUDP::BulletPositionUpdate* bulletposupdate) {
  delete bulletposupdate_;
  bulletposupdate_ = bulletposupdate;
  if (bulletposupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.DataMessage.bulletPosUpdate)
}

// optional .GameDataUDP.CollisionUpdate collisionUpdate = 5;
inline bool DataMessage::has_collisionupdate() const {
  return !_is_default_instance_ && collisionupdate_ != NULL;
}
inline void DataMessage::clear_collisionupdate() {
  if (GetArenaNoVirtual() == NULL && collisionupdate_ != NULL) delete collisionupdate_;
  collisionupdate_ = NULL;
}
inline const ::GameDataUDP::CollisionUpdate& DataMessage::collisionupdate() const {
  // @@protoc_insertion_point(field_get:GameDataUDP.DataMessage.collisionUpdate)
  return collisionupdate_ != NULL ? *collisionupdate_ : *default_instance_->collisionupdate_;
}
inline ::GameDataUDP::CollisionUpdate* DataMessage::mutable_collisionupdate() {
  
  if (collisionupdate_ == NULL) {
    collisionupdate_ = new ::GameDataUDP::CollisionUpdate;
  }
  // @@protoc_insertion_point(field_mutable:GameDataUDP.DataMessage.collisionUpdate)
  return collisionupdate_;
}
inline ::GameDataUDP::CollisionUpdate* DataMessage::release_collisionupdate() {
  // @@protoc_insertion_point(field_release:GameDataUDP.DataMessage.collisionUpdate)
  
  ::GameDataUDP::CollisionUpdate* temp = collisionupdate_;
  collisionupdate_ = NULL;
  return temp;
}
inline void DataMessage::set_allocated_collisionupdate(::GameDataUDP::CollisionUpdate* collisionupdate) {
  delete collisionupdate_;
  collisionupdate_ = collisionupdate;
  if (collisionupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:GameDataUDP.DataMessage.collisionUpdate)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameDataUDP

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameDataUDP_2eproto__INCLUDED
